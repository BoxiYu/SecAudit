import { Rule, Severity } from '../../types.js';

export const cRules: Rule[] = [
  // ── Buffer Overflow ──
  {
    id: 'C_STRCPY',
    category: 'Buffer Overflow',
    severity: Severity.High,
    message: 'strcpy() has no bounds checking — use strncpy() or strlcpy()',
    pattern: /\bstrcpy\s*\(/,
    fileExtensions: ['.c', '.cpp', '.h', '.hpp'],
    cwe: 'CWE-120',
    owasp: 'A06:2021',
    fix: { description: 'Replace strcpy(dst, src) with strncpy(dst, src, sizeof(dst)-1)' },
  },
  {
    id: 'C_STRCAT',
    category: 'Buffer Overflow',
    severity: Severity.High,
    message: 'strcat() has no bounds checking — use strncat() or strlcat()',
    pattern: /\bstrcat\s*\(/,
    fileExtensions: ['.c', '.cpp', '.h', '.hpp'],
    cwe: 'CWE-120',
    owasp: 'A06:2021',
    fix: { description: 'Replace strcat(dst, src) with strncat(dst, src, sizeof(dst)-strlen(dst)-1)' },
  },
  {
    id: 'C_SPRINTF',
    category: 'Buffer Overflow',
    severity: Severity.High,
    message: 'sprintf() has no bounds checking — use snprintf()',
    pattern: /\bsprintf\s*\(/,
    fileExtensions: ['.c', '.cpp', '.h', '.hpp'],
    cwe: 'CWE-120',
    owasp: 'A06:2021',
    fix: { description: 'Replace sprintf(buf, fmt, ...) with snprintf(buf, sizeof(buf), fmt, ...)' },
  },
  {
    id: 'C_GETS',
    category: 'Buffer Overflow',
    severity: Severity.Critical,
    message: 'gets() is always unsafe — use fgets()',
    pattern: /\bgets\s*\(/,
    fileExtensions: ['.c', '.cpp', '.h', '.hpp'],
    cwe: 'CWE-242',
    owasp: 'A06:2021',
    fix: { description: 'Replace gets(buf) with fgets(buf, sizeof(buf), stdin)' },
  },
  {
    id: 'C_SCANF_NO_WIDTH',
    category: 'Buffer Overflow',
    severity: Severity.High,
    message: 'scanf %s without width limit — specify max width',
    pattern: /scanf\s*\([^)]*"%[^"]*[^0-9]s/,
    fileExtensions: ['.c', '.cpp', '.h', '.hpp'],
    cwe: 'CWE-120',
    owasp: 'A06:2021',
    fix: { description: 'Use width specifier: scanf("%255s", buf) for char buf[256]' },
  },
  {
    id: 'C_VSPRINTF',
    category: 'Buffer Overflow',
    severity: Severity.High,
    message: 'vsprintf() has no bounds checking — use vsnprintf()',
    pattern: /\bvsprintf\s*\(/,
    fileExtensions: ['.c', '.cpp', '.h', '.hpp'],
    cwe: 'CWE-120',
    owasp: 'A06:2021',
  },
  {
    id: 'C_STPCPY',
    category: 'Buffer Overflow',
    severity: Severity.High,
    message: 'stpcpy() has no bounds checking — use stpncpy()',
    pattern: /\bstpcpy\s*\(/,
    fileExtensions: ['.c', '.cpp', '.h', '.hpp'],
    cwe: 'CWE-120',
    owasp: 'A06:2021',
  },
  {
    id: 'C_WCSCPY',
    category: 'Buffer Overflow',
    severity: Severity.High,
    message: 'wcscpy() has no bounds checking — use wcsncpy()',
    pattern: /\bwcscpy\s*\(/,
    fileExtensions: ['.c', '.cpp', '.h', '.hpp'],
    cwe: 'CWE-120',
    owasp: 'A06:2021',
  },

  // ── Format String ──
  {
    id: 'C_FORMAT_STRING',
    category: 'Format String',
    severity: Severity.Critical,
    message: 'printf-family with non-literal format string — format string attack',
    pattern: /(?:printf|fprintf|syslog|err|warn)\s*\(\s*(?!.*"[^"]*")[a-zA-Z_]\w*\s*\)/,
    fileExtensions: ['.c', '.cpp', '.h', '.hpp'],
    cwe: 'CWE-134',
    owasp: 'A03:2021',
    fix: { description: 'Always use a literal format string: printf("%s", user_input)' },
  },

  // ── Integer Overflow ──
  {
    id: 'C_MALLOC_MULTIPLY',
    category: 'Integer Overflow',
    severity: Severity.High,
    message: 'malloc with unchecked multiplication — may wrap to small allocation',
    pattern: /malloc\s*\(\s*\w+\s*\*\s*\w+\s*\)/,
    fileExtensions: ['.c', '.cpp', '.h', '.hpp'],
    cwe: 'CWE-190',
    owasp: 'A06:2021',
    fix: { description: 'Use calloc(count, size) or check for overflow before malloc(a*b)' },
  },
  {
    id: 'C_ATOI',
    category: 'Integer Overflow',
    severity: Severity.Medium,
    message: 'atoi() has no error checking — use strtol() with validation',
    pattern: /\batoi\s*\(/,
    fileExtensions: ['.c', '.cpp', '.h', '.hpp'],
    cwe: 'CWE-190',
    owasp: 'A06:2021',
    fix: { description: 'Use strtol() and check errno and endptr for errors' },
  },

  // ── Memory Safety ──
  {
    id: 'C_USE_AFTER_FREE',
    category: 'Memory Safety',
    severity: Severity.Critical,
    message: 'Pointer used after free — set to NULL after free()',
    pattern: /free\s*\(\s*(\w+)\s*\)\s*;(?!.*\1\s*=\s*NULL)/,
    fileExtensions: ['.c', '.cpp', '.h', '.hpp'],
    cwe: 'CWE-416',
    owasp: 'A06:2021',
    fix: { description: 'Set pointer to NULL immediately after free: free(p); p = NULL;' },
  },
  {
    id: 'C_DOUBLE_FREE',
    category: 'Memory Safety',
    severity: Severity.Critical,
    message: 'Potential double-free — ensure pointer is freed only once',
    pattern: /free\s*\(\s*\w+\s*\)[\s\S]{0,100}free\s*\(\s*\w+\s*\)/,
    fileExtensions: ['.c', '.cpp', '.h', '.hpp'],
    cwe: 'CWE-415',
    owasp: 'A06:2021',
  },
  {
    id: 'C_MALLOC_NO_CHECK',
    category: 'Memory Safety',
    severity: Severity.Medium,
    message: 'malloc() return not checked for NULL — may cause NULL dereference',
    pattern: /=\s*(?:malloc|calloc|realloc)\s*\([^)]+\)\s*;(?!\s*if)/,
    fileExtensions: ['.c', '.cpp', '.h', '.hpp'],
    cwe: 'CWE-252',
    owasp: 'A06:2021',
    fix: { description: 'Always check: ptr = malloc(n); if (!ptr) { handle error }' },
  },
  {
    id: 'C_MEMCPY_NO_CHECK',
    category: 'Buffer Overflow',
    severity: Severity.Medium,
    message: 'memcpy with potentially unchecked size — verify bounds',
    pattern: /memcpy\s*\([^,]+,\s*[^,]+,\s*(?!sizeof)[a-zA-Z_]\w*\s*\)/,
    fileExtensions: ['.c', '.cpp', '.h', '.hpp'],
    cwe: 'CWE-120',
    owasp: 'A06:2021',
  },

  // ── Race Conditions ──
  {
    id: 'C_TOCTOU_ACCESS',
    category: 'Race Condition',
    severity: Severity.Medium,
    message: 'access() before open() — TOCTOU race condition',
    pattern: /access\s*\([^)]+\)[\s\S]{0,80}(?:fopen|open)\s*\(/,
    fileExtensions: ['.c', '.cpp', '.h', '.hpp'],
    cwe: 'CWE-367',
    owasp: 'A04:2021',
    fix: { description: 'Open the file directly and check the return value instead of access()+open()' },
  },

  // ── Crypto ──
  {
    id: 'C_RAND',
    category: 'Weak Cryptography',
    severity: Severity.Medium,
    message: 'rand()/srand() is not cryptographically secure',
    pattern: /\b(?:srand|rand)\s*\(/,
    fileExtensions: ['.c', '.cpp', '.h', '.hpp'],
    cwe: 'CWE-338',
    owasp: 'A02:2021',
    fix: { description: 'Use /dev/urandom, arc4random(), or getrandom() for security-sensitive values' },
  },

  // ── Misc ──
  {
    id: 'C_SYSTEM',
    category: 'Command Injection',
    severity: Severity.High,
    message: 'system() executes via shell — vulnerable to injection',
    pattern: /\bsystem\s*\(\s*(?!["'])/,
    fileExtensions: ['.c', '.cpp', '.h', '.hpp'],
    cwe: 'CWE-78',
    owasp: 'A03:2021',
    fix: { description: 'Use execve() or posix_spawn() with explicit argv array' },
  },
  {
    id: 'C_TMPNAM',
    category: 'Race Condition',
    severity: Severity.Medium,
    message: 'tmpnam()/tempnam() is insecure — use mkstemp()',
    pattern: /\b(?:tmpnam|tempnam)\s*\(/,
    fileExtensions: ['.c', '.cpp', '.h', '.hpp'],
    cwe: 'CWE-377',
    owasp: 'A06:2021',
    fix: { description: 'Use mkstemp() for secure temporary files' },
  },
  {
    id: 'C_ALLOCA',
    category: 'Memory Safety',
    severity: Severity.Medium,
    message: 'alloca() allocates on stack — large sizes cause stack overflow',
    pattern: /\balloca\s*\(/,
    fileExtensions: ['.c', '.cpp', '.h', '.hpp'],
    cwe: 'CWE-770',
    owasp: 'A06:2021',
  },
  {
    id: 'C_REALPATH_BUF',
    category: 'Buffer Overflow',
    severity: Severity.Medium,
    message: 'realpath() with fixed buffer — pass NULL to auto-allocate',
    pattern: /realpath\s*\([^,]+,\s*[a-zA-Z_]\w*\s*\)/,
    fileExtensions: ['.c', '.cpp', '.h', '.hpp'],
    cwe: 'CWE-120',
    owasp: 'A06:2021',
  },
];
